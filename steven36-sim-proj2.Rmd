---
title: 'Week 6 - Simulation Project'
author: "STAT 420, Summer 2020, D. Unger"
date: ''
output:
  html_document: 
    theme: readable
    toc: yes  
  pdf_document: default
urlcolor: cyan
---

***

```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
options(scipen = 1, digits = 4, width = 80)
library(knitr)
opts_chunk$set(cache = TRUE, autodep = TRUE)
```



```{r}
birthday = 030370
set.seed(birthday)
```

# Simulation Study 1: Significance of Regression

In this simulation study we will investigate the significance of regression test. We will simulate from two different models:

1. The **"significant"** model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 3$,
- $\beta_1 = 1$,
- $\beta_2 = 1$,
- $\beta_3 = 1$.


2. The **"non-significant"** model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 3$,
- $\beta_1 = 0$,
- $\beta_2 = 0$,
- $\beta_3 = 0$.

For both, we will consider a sample size of $25$ and three possible levels of noise. That is, three values of $\sigma$.

- $n = 25$
- $\sigma \in (1, 5, 10)$

Use simulation to obtain an empirical distribution for each of the following values, for each of the three values of $\sigma$, for both models.

- The **$F$ statistic** for the significance of regression test.
- The **p-value** for the significance of regression test
- **$R^2$**

For each model and $\sigma$ combination, use $2000$ simulations. For each simulation, fit a regression model of the same form used to perform the simulation.

Use the data found in [`study_1.csv`](study_1.csv) for the values of the predictors. These should be kept constant for the entirety of this study. The `y` values in this data are a blank placeholder.

Done correctly, you will have simulated the `y` vector $2 (models)×3 (sigmas)×2000 (sims)=12000$ times.

Potential discussions:

- Do we know the true distribution of any of these values?
- How do the empirical distributions from the simulations compare to the true distributions? (You could consider adding a curve for the true distributions if you know them.)
- How are each of the $F$ statistic, the p-value, and $R^2$ related to $\sigma$? Are any of those relationships the same for the significant and non-significant models?

Additional things to consider:

- Organize the plots in a grid for easy comparison.
```{r, eval=FALSE}
n = 25
p = 4 #no. of parameters
dfx = read.csv("study_1.csv")
B = c(3,1,1,1)
X = as.matrix(cbind("x0" = rep(1, n), dfx[ ,2:ncol(dfx)]))
S = c(1, 5, 10)  

get_Anova = function(n, B, X, sigma, df) {
  noise = rnorm(n, mean = 0, sd = sigma)   
  y = X %*% B + noise
  df[ , 1] = as.vector(y)
  m0 = lm(y ~ 1, data = df)
  m1 = lm(y ~ ., data = df) 
  a = anova(m0, m1)
  c(a[2,5], a[2,6], summary(m1)$r.squared)
}
 

#a = get_Anova(n, B, X, 1, dfx)
#a
data_mx1 = matrix(0, 2000, 3)
data_mx2 = matrix(0, 2000, 3)
data_mx3 = matrix(0, 2000, 3)

for (i in 1:2000) {
  data_mx1[i, ] = get_Anova(n, B, X, S[1], dfx)
  data_mx2[i, ] = get_Anova(n, B, X, S[2], dfx)
  data_mx3[i, ] = get_Anova(n, B, X, S[3], dfx)
}

```

```{r}

n = 25
p = 4 #no. of parameters
dfx = read.csv("study_1.csv")
X_pred = as.matrix(cbind("x0" = rep(1, n), dfx[ ,2:ncol(dfx)]))
S = c(1, 5, 10)  

#function input: n = #obs, B = beta vector, X = predictor matrix w leading 1s, sigma = stdev, df = dataframe of x(pred) and y values
#function output: a vector of F stat, p-value, Rsquared 
get_vals = function(n, B, X, sigma, df) {
  noise = rnorm(n, mean = 0, sd = sigma)   
  y = X %*% B + noise
  df[ , 1] = as.vector(y)
  m = lm(y ~ ., data = df)
  f = summary(m)$fstatistic
  p = pf(q = f[1], df1 = f[2], df2 = f[3], lower.tail = FALSE)
  rsq = summary(m)$r.squared
  vec = c(f[1], p, rsq)
  as.vector(vec)
}
#matrices to store data of sig and non-sig model
vals0 = matrix(0, 2000, 9)  #non-sig model
vals1 = matrix(0, 2000, 9)  #sig model

#loops to simulate model 2000 times for 3 different noise levels
k=0
for (i in 1:3) {
  a = i+k
  b = i+k+2
  for (j in 1:2000) {
    vals1[ j, a : b] = get_vals(n, B = c(3,1,1,1), X_pred, S[i], dfx)
    vals0[ j, a : b] = get_vals(n, B = c(3,0,0,0), X_pred, S[i], dfx)
  }
  k=k+2
}
```

```{r}
#pval
par(mfrow = c(1,3))
hist(vals1[ , 2], breaks = 30)
hist(vals1[ , 5], breaks = 30)
hist(vals1[ , 8], breaks = 30)

c(mean(vals1[ ,2]), mean(vals1[ ,5]), mean(vals1[ ,8]))
  
```


```{r}
#Fstat
par(mfrow = c(1,3))
hist(vals1[ , 1], breaks = 30)
hist(vals1[ , 4], breaks = 30)
hist(vals1[ , 7], breaks = 30)

c(mean(vals1[ ,1]), mean(vals1[ ,4]), mean(vals1[ ,7]))


```

```{r}
#Rsq
par(mfrow = c(1,3))
hist(vals1[ , 3], breaks = 30)
hist(vals1[ , 6], breaks = 30)
hist(vals1[ , 9], breaks = 30)

c(mean(vals1[ ,3]), mean(vals1[ ,6]), mean(vals1[ ,9]))


```

```{r}
#Fstat

par(mfrow = c(1,3))
hist(vals0[ , 1], breaks = 30)
hist(vals0[ , 4], breaks = 30)
hist(vals0[ , 7], breaks = 30)

c(mean(vals0[ ,1]), mean(vals0[ ,4]), mean(vals0[ ,7]))
```


```{r}
#pval

par(mfrow = c(1,3))
hist(vals0[ , 2], breaks = 30)
hist(vals0[ , 5], breaks = 30)
hist(vals0[ , 8], breaks = 30)

c(mean(vals0[ ,2]), mean(vals0[ ,5]), mean(vals0[ ,8]))
```

```{r}
#Rsq

par(mfrow = c(1,3))
hist(vals0[ , 3], breaks = 30)
hist(vals0[ , 6], breaks = 30)
hist(vals0[ , 9], breaks = 30)

c(mean(vals0[ ,3]), mean(vals0[ ,6]), mean(vals0[ ,9]))
```



```{r, eval=FALSE}
#hist("a" = data_mx1[ ,1], "b" = data_mx2[ , 1], "c" = data_mx3[ , 1])

hist(data_mx1[ , 1], breaks = 40, prob = TRUE)
#curve(df(x, df1 = p - 1, df2 = n - p), col = "orange", add = TRUE)
hist(data_mx2[ , 1], breaks = 40)
hist(data_mx3[ , 1], breaks = 40)
```

```{r, eval=FALSE}
hist(data_mx1[ , 2], breaks = 30)
hist(data_mx2[ , 2], breaks = 30)
hist(data_mx3[ , 2], breaks = 30)
```
```{r, eval=FALSE}
hist(data_mx1[ , 3], breaks = 30)
hist(data_mx2[ , 3], breaks = 30)
hist(data_mx3[ , 3], breaks = 30)
```



```{r, eval=FALSE}
temp_vec = rf(2000, df1 = p-1, df2 = n-p)
hist(temp_vec, breaks = 50, probability = TRUE)
curve(df(x, df1 = p-1, df2 = n-p), add = TRUE )

```

```{r, eval=FALSE}
range(data_mx1[ ,2])
range(data_mx2[ ,2])
range(data_mx3[ ,2])

mean(data_mx1[ ,2])
mean(data_mx2[ ,2])
mean(data_mx3[ ,2])
```


### Introduction study one:

One of the goals of this study is to examine the role of noise as a function of the F statistic and p-value in the context of determining the significance of the regression model.  The regression model has 3 predictors, and this study examines two different sets of beta parameters. The null hypothesis is, $H_0:  \beta_1 = \beta_2 = \beta_3 = 0$ and the alternate hypothesis is, $H_1: at\ least\ one\ \beta_1, \beta_2, \beta_3 \ne 0$.  Furthmore, $R^2$, will also be calculated to determine its effect as a function of noise.      

### Methods

To carry out this study, we defined a true linear model where the beta parameters and sigma are known.  The true model was defined as: 

  $Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \epsilon_i$ 
  
  where $\epsilon_i \sim N(0, \sigma^2)$ and the two sets of beta parameters are,
  
Significant Model:
- $\beta_0 = 3$,
- $\beta_1 = 1$,
- $\beta_2 = 1$,
- $\beta_3 = 1$, 

Non-Significant Model:
- $\beta_0 = 3$,
- $\beta_1 = 0$,
- $\beta_2 = 0$,
- $\beta_3 = 0$.

To obtain empirical data we performed simulations using the true model and added noise to it.  The amount of noise was varied by $\sigma \in (1, 5, 10)$.  The x values, predictors, were fixed and obtained from study_1.csv file.  A function called get_Anova() was created to obtain the F statistic, p-value, and $R^2$ value.  It inputs the beta vector, X input matrix, and noise level as parameters and creates both the null and full model using the lm() function.  The anova() function was used to calculate the F statistic and p-value from these two models.  This was performed 2000 times for each noise level.  

### Results

### Discussion


In the significant model (beta parameters are non-zero), as noise increased the significance of regression decreased.  This is supported by the decrease in the F statistic and increase in the p-value as noise increases, as shown in the histograms.  When noise level is at its lowest, sigma = 1, the p-value is extremely low. The mean is < 1e-6.  This tells us that we should reject the null hypothesis and that at least one of the predictors has a linear relationship with y when all three predictors, x1, x2, and x3 are included in the analysis.  We should expect this because the true model has non-zero beta parameters.  At noise levels $\sigma = \sqrt{5}\ and\ \sqrt{10}$ the mean p-values are 0.008 and 0.06, respectively.  Assuming we set the probability criteria to $\alpha = 0.05$, a greater portion of the simulation values are starting to fail to reject the null hypothesis due to increased noise level.  

We should expect this since noise increases the spread of y.  This can affect the F statistic by reducing the SSReg.  The increased noise will cause a worse regression fit thereby reducing the SSReg value.  The SSE can also be affected by a larger spread causing the error to increase.  The combined effects will reduce the F statistic which is given by F = SSReg/SSE.  A smaller F statistic will in turn result in a high p-value given by the F distribution with df1 = p-1 and df2 = n-p.    

SSE (sum of squares error).  As SSE increases the F statistic decreases which can be shown by F = SSReg/SSE. The Rsquared values collected in this study also supports the summary above.  As noise increases the Rsquared value decreases which translates to less of the variation in y can be explained by the regression model.  This can be seen in the histogram plots.  Mathematically speaking, as noise increases SSE also increases which decreases Rsquared since Rsquared = 1 - SSE/SST.     

If we look at the non-significant model where all beta parameters are zero (excluding beta intercept),  we notice that most of the time we fail to reject the null hypothesis, as should be the case since the non-intercept beta values are all zero in the true model.  On average, the F statistic was 1.1 and the p-value was 0.5.  The Rsquared value was quite low at 0.12. Another thing to note, in contrast to the significant model, the mean values of the F statistic, p-value and Rsquared values were little affected by the noise level.  The explaination is that there was no significance in the regression model to start with...The response is essentially predicted by the mean of y regardless the of x values.  


# Simulation Study 2: Using RMSE for Selection?

In homework we saw how Test RMSE can be used to select the “best” model. In this simulation study we will investigate how well this procedure works. Since splitting the data is random, we don’t expect it to work correctly each time. We could get unlucky. But averaged over many attempts, we should expect it to select the appropriate model.

We will simulate from the model

\[
Y_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i3} + \beta_4 x_{i4} + \beta_5 x_{i5} + \beta_6 x_{i6} + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$ and

- $\beta_0 = 0$,
- $\beta_1 = 3$,
- $\beta_2 = -4$,
- $\beta_3 = 1.6$,
- $\beta_4 = -1.1$,
- $\beta_5 = 0.7$,
- $\beta_6 = 0.5$.

We will consider a sample size of $500$ and three possible levels of noise. That is, three values of $\sigma$.

- $n = 500$
- $\sigma \in (1, 2, 4)$

Use the data found in [`study_2.csv`](study_2.csv) for the values of the predictors. These should be kept constant for the entirety of this study. The `y` values in this data are a blank placeholder.

Each time you simulate the data, randomly split the data into train and test sets of equal sizes (250 observations for training, 250 observations for testing).

For each, fit **nine** models, with forms:

- `y ~ x1`
- `y ~ x1 + x2`
- `y ~ x1 + x2 + x3`
- `y ~ x1 + x2 + x3 + x4`
- `y ~ x1 + x2 + x3 + x4 + x5`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6`, the correct form of the model as noted above
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8`
- `y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9`

For each model, calculate Train and Test RMSE.

\[
\text{RMSE}(\text{model, data}) = \sqrt{\frac{1}{n} \sum_{i = 1}^{n}(y_i - \hat{y}_i)^2}
\]

Repeat this process with $1000$ simulations for each of the $3$ values of $\sigma$. For each value of $\sigma$, create a plot that shows how average Train RMSE and average Test RMSE changes as a function of model size. Also show the number of times the model of each size was chosen for each value of $\sigma$.

Done correctly, you will have simulated the $y$ vector $3×1000=3000$ times. You will have fit $9×3×1000=27000$ models. A minimal result would use $3$ plots. Additional plots may also be useful.

Potential discussions:

- Does the method **always** select the correct model? On average, does is select the correct model?
- How does the level of noise affect the results?

```{r}
study2 = read.csv("study_2.csv")
#this function splits and shuffles the study2 dframe, trn and tst dframe stored in a list
train_test = function(df, ratio) {
  n = nrow(df)
  ncols = ncol(df)
  n_train = n * ratio
  #mx = as.matrix(df)
  shuffle_index = sample(1:n, n)
  train = data.frame(matrix(0, n_train, ncols))
  colnames(train) = c("y", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")
  test = data.frame(matrix(0, n - n_train, ncols))
  colnames(test) = c("y", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9")
  for (i in 1:n_train) {
    indx = shuffle_index[i]
    train[i,] = df[indx, ]
  }
  for (i in 1 : n - n_train) {
    indx = shuffle_index[n_train + i]
    test[i, ] = df[indx, ]
  }
  list(train, test)
}

```

```{r}

B = c(0, 3, -4, 1.6, -1.1, 0.7, 0.5)
S = c(1, 2, 4)  

#function input: n = #obs, B = beta vector, X = predictor matrix w leading 1s, sigma = stdev, df = dataframe of x(pred) and y values
#function output: a vector of F stat, p-value, Rsquared 
get_rmse = function(B, sigma, df, ratio) {
  n = nrow(df)
  X = as.matrix(cbind("x0" = rep(1, n), df[ ,2:7])) #this is for true model, only betas x0-x6 required
  noise = rnorm(n, mean = 0, sd = sigma)   
  y = X %*% B + noise
  df[ , 1] = as.vector(y)
  temp = train_test(df, ratio)  
  trn = temp[[1]] #this is a data frame
  tst = temp[[2]]
  n_trn = nrow(trn)  #n_train in this case is 250 
  n_tst = nrow(tst)
  m1 = lm(y ~ x1, data = trn)
  m2 = lm(y ~ x1 + x2, data = trn)
  m3 = lm(y ~ x1 + x2 + x3, data = trn)  
  m4 = lm(y ~ x1 + x2 + x3 + x4, data = trn)  
  m5 = lm(y ~ x1 + x2 + x3 + x4 + x5, data = trn)  
  m6 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6, data = trn)  
  m7 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7, data = trn)  
  m8 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8, data = trn)  
  m9 = lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9, data = trn)  
  models = list(m1, m2, m3, m4, m5, m6, m7, m8, m9)
  rmse_train = rep(0, length(models))
  rmse_test = rep(0, length(models))
  for (i in 1:length(models))  {
    err = resid(models[[i]])
    rmse_trn = sqrt(sum(err^2)/n_trn) 
    yhat = predict(models[[i]], newdata = tst)
    e = yhat - tst[ , 1]
    rmse_tst = sqrt(sum(e^2)/n_tst)
    rmse_train[i] = rmse_trn
    rmse_test[i] = rmse_tst
  } 
  list(rmse_train, rmse_test)
}

```


```{r}
performSim = function(B, sigma, df, ratio, n_sim, n_model) {
  n_column = n_model * 2
  n_modelp1 = n_model + 1
  data = matrix(0, n_sim, n_column)
  for (i in 1:n_sim) {
    temp = get_rmse(B, sigma, df, ratio)
    data[i, 1:n_model] = temp[[1]]
    data[i, n_modelp1:n_column] = temp[[2]]
  }
  data
}
```

```{r, eval=TRUE}
data_sig1 = performSim(B, sigma = S[1], df = study2, ratio = 0.5, n_sim = 1000, n_model = 9)
data_sig2 = performSim(B, sigma = S[2], df = study2, ratio = 0.5, n_sim = 1000, n_model = 9)
data_sig3 = performSim(B, sigma = S[3], df = study2, ratio = 0.5, n_sim = 1000, n_model = 9)
```

```{r}
par(mfrow = c(1,2))
boxplot(data_sig1[, 1:9])
boxplot(data_sig1[ , 10:18])
```

```{r}
par(mfrow = c(1,2))
boxplot(data_sig2[, 1:9])
boxplot(data_sig2[ , 10:18])
```

```{r}
par(mfrow = c(1,2))
boxplot(data_sig3[, 1:9])
boxplot(data_sig3[ , 10:18])
```





# Simulation Study 3: Power

In this simulation study we will investigate the **power** of the significance of regression test for simple linear regression. 

\[
H_0: \beta_{1} = 0 \ \text{vs} \ H_1: \beta_{1} \neq 0
\]

Recall, we had defined the *significance* level, $\alpha$, to be the probability of a Type I error.

\[
\alpha = P[\text{Reject } H_0 \mid H_0 \text{ True}] = P[\text{Type I Error}]
\]

Similarly, the probability of a Type II error is often denoted using $\beta$; however, this should not be confused with a regression parameter.

\[
\beta = P[\text{Fail to Reject } H_0 \mid H_1 \text{ True}] = P[\text{Type II Error}]
\]

*Power* is the probability of rejecting the null hypothesis when the null is not true, that is, the alternative is true and $\beta_{1}$ is non-zero.

\[
\text{Power} = 1 - \beta = P[\text{Reject } H_0 \mid H_1 \text{ True}]
\]

Essentially, power is the probability that a signal of a particular strength will be detected. Many things affect the power of a test. In this case, some of those are:

- Sample Size, $n$
- Signal Strength, $\beta_1$
- Noise Level, $\sigma$
- Significance Level, $\alpha$

We'll investigate the first three.

To do so we will simulate from the model

\[
Y_i = \beta_0 + \beta_1 x_i + \epsilon_i
\]

where $\epsilon_i \sim N(0, \sigma^2)$.

For simplicity, we will let $\beta_0 = 0$, thus $\beta_1$ is essentially controlling the amount of "signal." We will then consider different signals, noises, and sample sizes:

- $\beta_1 \in (-2, -1.9, -1.8, \ldots, -0.1, 0, 0.1, 0.2, 0.3, \ldots 1.9, 2)$
- $\sigma \in (1, 2, 4)$
- $n \in (10, 20, 30)$

We will hold the significance level constant at $\alpha = 0.05$.

Use the following code to generate the predictor values, `x`: values for different sample sizes.

```{r eval=FALSE}
x_values = seq(0, 5, length = n)
```

For each possible $\beta_1$ and $\sigma$ combination, simulate from the true model at least $1000$ times. Each time, perform the significance of the regression test. To estimate the power with these simulations, and some $\alpha$, use

\[
\hat{\text{Power}} = \hat{P}[\text{Reject } H_0 \mid H_1 \text{ True}] = \frac{\text{# Tests Rejected}}{\text{# Simulations}}
\]

It is *possible* to derive an expression for power mathematically, but often this is difficult, so instead, we rely on simulation.

Create three plots, one for each value of $\sigma$. Within each of these plots, add a “power curve” for each value of $n$ that shows how power is affected by signal strength, $\beta_1$.

Potential discussions:

- How do $n$, $\beta_1$, and $\sigma$ affect power? Consider additional plots to demonstrate these effects.
- Are $1000$ simulations sufficient?

```{r}
set.seed(10)

beta = seq(-2, 2, .1)

S = c(1, 2, 4)  

#function input: n = #obs, B = beta vector, X = predictor matrix w leading 1s, sigma = stdev, df = dataframe of x(pred) and y values
#function output: a vector of F stat, p-value, Rsquared

get_pval = function(n, B, sigma) {
  x_values = seq(0, 5, length = n)
  df = data.frame("y" = rep(0,n), "x1" = x_values)
  X = as.matrix(cbind("x0" = rep(1, n), "x1" = x_values ))
  noise = rnorm(n, mean = 0, sd = sigma)   
  y = X %*% B + noise
  df[ , 1] = as.vector(y)
  m = lm(y ~ x1, data = df)
  pval = pf(q=summary(m)$fstatistic[1], df1 = length(coef(m)) - 1, df2 = n - length(coef(m)), lower.tail = FALSE)
}

simulate = function(n, beta, sigma, n_sim) {
  power_vec = c(0, length(beta))
  for (k in 1:length(beta)){
    B = c(0, beta[k])
    p_vec = rep(0, n_sim)
  
    for (i in 1:n_sim) {
      p_vec[i] = get_pval(n, B, sigma)
    }
    
    power_vec[k] = sum(p_vec < 0.05)/n_sim   #power = total Ho rejected/total simulations
  }
  power_vec
}
```

```{r}
p1 = simulate(n=10, beta, S[1], n_sim = 1000)
p2 = simulate(n=20, beta, S[1], n_sim = 1000)
p3 = simulate(n=30, beta, S[1], n_sim = 1000)

p4 = simulate(n=10, beta, S[2], n_sim = 1000)
p5 = simulate(n=20, beta, S[2], n_sim = 1000)
p6 = simulate(n=30, beta, S[2], n_sim = 1000)

p7 = simulate(n=10, beta, S[3], n_sim = 1000)
p8 = simulate(n=20, beta, S[3], n_sim = 1000)
p9 = simulate(n=30, beta, S[3], n_sim = 1000)

```



```{r}
plot(p1 ~ beta)
```

